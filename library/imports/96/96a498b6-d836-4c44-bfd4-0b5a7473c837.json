{
  "__type__": "cc.TextAsset",
  "_name": "wx.d",
  "_objFlags": 0,
  "_native": "",
  "text": "/**\r\n * 取消一个先前通过调用 requestAnimationFrame 方法添加到计划中的动画帧请求\r\n */\r\ndeclare function cancelAnimationFrame(requestID: number): void;\r\n\r\n/**\r\n * 在下次进行重绘时执行。\r\n */\r\ndeclare function requestAnimationFrame(callback: ()=>void): number;\r\n\r\n/**\r\n * 可取消由 setTimeout() 方法设置的定时器。\r\n */\r\ndeclare function clearTimeout(timeoutID: number): void;\r\n\r\n/**\r\n * 可取消由 setInterval() 方法设置的定时器。\r\n */\r\ndeclare function clearInterval(intervalID: number): void;\r\n\r\n/**\r\n * 设定一个定时器，在定时到期以后执行注册的回调函数\r\n */\r\ndeclare function setTimeout(callback: ()=>void, delay: number, rest: any): number;\r\n\r\n/**\r\n * 设定一个定时器，按照指定的周期（以毫秒计）来执行注册的回调函数\r\n */\r\ndeclare function setInterval(callback: ()=>void, delay: number, rest: any): number;\r\n\r\ndeclare const wx: {\r\n\r\n    cloud: {\r\n        callFunction(options: Object):any;\r\n        database(options?: object): Database;\r\n        collection(name: string): Collection;\r\n        doc(id: string | number): Document;\r\n        get(options?: object): Promise<Result>;\r\n        init(options): void;\r\n    }\r\n\r\n    aldStage:{\r\n        onStart(options:{stageId:string,stageName:string,userId?:string})\r\n        /**\r\n         *  \r\n         * @param options.event payStart:发起支付\r\n                paySuccess:支付成功\r\n                payFail:支付失败\r\n                tools:使用道具 \r\n                revive:复活\r\n                award:奖励\r\n         */\r\n        onRunning(options:{stageId:string,stageName:string,userId?:string,event:string,params:{itemName:string,itemId?:string,itemCount?:number,desc?:string,itemMoney?:string}})\r\n        /**\r\n         *  \r\n         * @param options.event complete:关卡完成\r\n            fail:关卡失败\r\n         */\r\n        onEnd(options:{stageId:string,stageName:string,userId?:string,event:string,params:{desc?:string}})\r\n        \r\n    }\r\n    aldSendEvent(eventName,params?:Object)\r\n\r\n    /**\r\n     *  sessionFrom\tstring\t''\t否\t会话来源\t\r\n        showMessageCard\tboolean\tfalse\t否\t是否显示会话内消息卡片，设置此参数为 true，用户进入客服会话之后会收到一个消息卡片，通过以下三个参数设置卡片的内容\t\r\n        sendMessageTitle\tstring\t''\t否\t会话内消息卡片标题\t\r\n        sendMessagePath\tstring\t''\t否\t会话内消息卡片路径\t\r\n        sendMessageImg\tstring\t''\t否\t会话内消息卡片图片路径\t\r\n        success\tfunction\t\t否\t接口调用成功的回调函数\t\r\n        fail\tfunction\t\t否\t接口调用失败的回调函数\t\r\n        complete\tfunction\t\t否\t接口调用结束的回调函数（调用成功、失败都会执行）\r\n     */\r\n\r\n    openCustomerServiceConversation(any):any;\r\n\r\n    navigateToMiniProgram(any):any;\r\n\r\n    createUserInfoButton(any):any;\r\n    /**\r\n     * 创建一个画布对象。首次调用创建的是显示在屏幕上的画布，之后调用创建的都是离屏画布。\r\n     */\r\n    createCanvas(): Canvas;\r\n    /**\r\n     * 只有开放数据域能调用，获取主域和开放数据域共享的 sharedCanvas\r\n     */\r\n    getSharedCanvas(): Canvas;\r\n    /**\r\n     * 创建一个图片对象\r\n     */\r\n    createImage(): Image;\r\n    /**\r\n     * 获取一行文本的行高\r\n     */\r\n    getTextLineHeight(object: {fontStyle:string,fontWeight:string,fontSize:number,fontFamily:string,text:string,success:(res:any)=>void,fail:(res:any)=>void,complete:(res:any)=>void}): number;\r\n    /**\r\n     * 加载自定义字体文件\r\n     */\r\n    loadFont(path: string): string;\r\n    /**\r\n     * 可以修改渲染帧率。默认渲染帧率为 60 帧每秒。修改后，requestAnimationFrame 的回调频率会发生改变。\r\n     */\r\n    setPreferredFramesPerSecond(fps: number): void;\r\n    /**\r\n     * 退出当前小游戏\r\n     */\r\n    exitMiniProgram(object: {success:(res:any)=>void,fail:(res:any)=>void,complete:(res:any)=>void}): void;\r\n    /**\r\n     * 返回小程序启动参数\r\n     */\r\n    getLaunchOptionsSync(): LaunchOption;\r\n    /**\r\n     * 监听小游戏隐藏到后台事件。锁屏、按 HOME 键退到桌面、显示在聊天顶部等操作会触发此事件。\r\n     */\r\n    onHide(callback: ()=>void): void;\r\n    /**\r\n     * 取消监听小游戏隐藏到后台事件。锁屏、按 HOME 键退到桌面、显示在聊天顶部等操作会触发此事件。\r\n     */\r\n    offHide(callback: ()=>void): void;\r\n    /**\r\n     * 监听小游戏回到前台的事件\r\n     */\r\n    onShow(callback: (res)=>void): void;\r\n    /**\r\n     * 取消监听小游戏回到前台的事件\r\n     */\r\n    offShow(callback: ()=>void): void;\r\n    /**\r\n     * 获取系统信息\r\n     */\r\n    getSystemInfo(object: {success:(res:any)=>void,fail:(res:any)=>void,complete:(res:any)=>void}): void;\r\n    /**\r\n     * wx.getSystemInfo 的同步版本\r\n     */\r\n    getSystemInfoSync(): SystemInfo;\r\n    /**\r\n     * 监听音频中断结束，在收到 onAudioInterruptionBegin 事件之后，小程序内所有音频会暂停，收到此事件之后才可再次播放成功\r\n     */\r\n    onAudioInterruptionEnd(callback: ()=>void): void;\r\n    /**\r\n     * 取消监听音频中断结束，在收到 onAudioInterruptionBegin 事件之后，小程序内所有音频会暂停，收到此事件之后才可再次播放成功\r\n     */\r\n    offAudioInterruptionEnd(callback: ()=>void): void;\r\n    /**\r\n     * 监听音频因为受到系统占用而被中断开始，以下场景会触发此事件：闹钟、电话、FaceTime 通话、微信语音聊天、微信视频聊天。此事件触发后，小程序内所有音频会暂停。\r\n     */\r\n    onAudioInterruptionBegin(callback: ()=>void): void;\r\n    /**\r\n     * 取消监听音频因为受到系统占用而被中断开始，以下场景会触发此事件：闹钟、电话、FaceTime 通话、微信语音聊天、微信视频聊天。此事件触发后，小程序内所有音频会暂停。\r\n     */\r\n    offAudioInterruptionBegin(callback: ()=>void): void;\r\n    /**\r\n     * 监听全局错误事件\r\n     */\r\n    onError(callback: ()=>void): void;\r\n    /**\r\n     * 取消监听全局错误事件\r\n     */\r\n    offError(callback: ()=>void): void;\r\n    /**\r\n     * 监听开始触摸事件\r\n     */\r\n    onTouchStart(callback: ()=>void): void;\r\n    /**\r\n     * 取消监听开始触摸事件\r\n     */\r\n    offTouchStart(callback: ()=>void): void;\r\n    /**\r\n     * 监听触点移动事件\r\n     */\r\n    onTouchMove(callback: ()=>void): void;\r\n    /**\r\n     * 取消监听触点移动事件\r\n     */\r\n    offTouchMove(callback: ()=>void): void;\r\n    /**\r\n     * 监听触摸结束事件\r\n     */\r\n    onTouchEnd(callback: ()=>void): void;\r\n    /**\r\n     * 取消监听触摸结束事件\r\n     */\r\n    offTouchEnd(callback: ()=>void): void;\r\n    /**\r\n     * 监听触点失效事件\r\n     */\r\n    onTouchCancel(callback: ()=>void): void;\r\n    /**\r\n     * 取消监听触点失效事件\r\n     */\r\n    offTouchCancel(callback: ()=>void): void;\r\n    /**\r\n     * 监听加速度数据，频率：5次/秒，接口调用后会自动开始监听，可使用 wx.stopAccelerometer 停止监听。\r\n     */\r\n    onAccelerometerChange(callback: ()=>void): void;\r\n    startAccelerometer(object: {success:(res:any)=>void,fail:(res:any)=>void,complete:(res:any)=>void}): void;\r\n    stopAccelerometer(object: {success:(res:any)=>void,fail:(res:any)=>void,complete:(res:any)=>void}): void;\r\n    /**\r\n     * 获取设备电量\r\n     */\r\n    getBatteryInfo(object: {success:(res:any)=>void,fail:(res:any)=>void,complete:(res:any)=>void}): void;\r\n    /**\r\n     * wx.getBatteryInfo 的同步版本\r\n     */\r\n    getBatteryInfoSync(): string;\r\n    getClipboardData(object: {success?:(res:any)=>void,fail?:(res:any)=>void,complete?:(res:any)=>void}): void;\r\n    setClipboardData(object: {data:string,success?:(res:any)=>void,fail?:(res:any)=>void,complete?:(res:any)=>void}): void;\r\n    /**\r\n     * 监听罗盘数据，频率：5 次/秒，接口调用后会自动开始监听，可使用 wx.stopCompass 停止监听。\r\n     */\r\n    onCompassChange(callback: ()=>void): void;\r\n    startCompass(object: {success:(res:any)=>void,fail:(res:any)=>void,complete:(res:any)=>void}): void;\r\n    stopCompass(object: {success:(res:any)=>void,fail:(res:any)=>void,complete:(res:any)=>void}): void;\r\n    /**\r\n     * 获取网络类型\r\n     */\r\n    getNetworkType(object: {success:(res:any)=>void,fail:(res:any)=>void,complete:(res:any)=>void}): void;\r\n    onNetworkStatusChange(callback: ()=>void): void;\r\n    getScreenBrightness(object: {success:(res:any)=>void,fail:(res:any)=>void,complete:(res:any)=>void}): void;\r\n    setKeepScreenOn(object: {keepScreenOn:boolean,success:(res:any)=>void,fail:(res:any)=>void,complete:(res:any)=>void}): void;\r\n    setScreenBrightness(object: {value:number,success:(res:any)=>void,fail:(res:any)=>void,complete:(res:any)=>void}): void;\r\n    vibrateShort(object?: {success?:(res:any)=>void,fail?:(res:any)=>void,complete?:(res:any)=>void}): void;\r\n    vibrateLong(object?: {success?:(res:any)=>void,fail?:(res:any)=>void,complete?:(res:any)=>void}): void;\r\n    /**\r\n     * 获取全局唯一的文件管理器\r\n     */\r\n    getFileSystemManager(): FileSystemManager;\r\n    /**\r\n     * 获取当前的地理位置、速度。当用户离开小程序后，此接口无法调用；当用户点击“显示在聊天顶部”时，此接口可继续调用。\r\n     */\r\n    getLocation(object: {type:string,success:(res:any)=>void,fail:(res:any)=>void,complete:(res:any)=>void}): void;\r\n    /**\r\n     * 下载文件资源到本地，客户端直接发起一个 HTTP GET 请求，返回文件的本地文件路径。\r\n     */\r\n    downloadFile(object: {url:string,header:Object,filePath:string,fail:(res:any)=>void,complete:(res:any)=>void}): DownloadTask;\r\n    /**\r\n     * 发起网络请求。\r\n     */\r\n    request(object: {url:string,data:string|Object,header:Object,method:string,dataType:string,success:(res:any)=>void,fail:(res:any)=>void,complete:(res:any)=>void}): RequestTask;\r\n    /**\r\n     * 创建一个 WebSocket 连接。最多同时存在 2 个 WebSocket 连接。\r\n     */\r\n    connectSocket(object: {url:string,header:Object,method:string,protocols:any[],success:(res:any)=>void,fail:(res:any)=>void,complete:(res:any)=>void}): SocketTask;\r\n    /**\r\n     * 关闭 WeSocket 连接\r\n     */\r\n    closeSocket(object: {code:number,reason:string,success:(res:any)=>void,fail:(res:any)=>void,complete:(res:any)=>void}): void;\r\n    /**\r\n     * 监听WebSocket 连接打开事件\r\n     */\r\n    onSocketOpen(callback: ()=>void): void;\r\n    /**\r\n     * 监听WebSocket 连接关闭事件\r\n     */\r\n    onSocketClose(callback: ()=>void): void;\r\n    /**\r\n     * 监听WebSocket 接受到服务器的消息事件\r\n     */\r\n    onSocketMessage(callback: ()=>void): void;\r\n    /**\r\n     * 监听WebSocket 错误事件\r\n     */\r\n    onSocketError(callback: ()=>void): void;\r\n    /**\r\n     * 通过 WebSocket 连接发送数据，需要先 wx.connectSocket，并在 wx.onSocketOpen 回调之后才能发送。\r\n     */\r\n    sendSocketMessage(object: {data:any[],success:(res:any)=>void,fail:(res:any)=>void,complete:(res:any)=>void}): void;\r\n    /**\r\n     * 将本地资源上传到开发者服务器，客户端发起一个 HTTPS POST 请求，其中 content-type 为 multipart/form-data 。\r\n     */\r\n    uploadFile(object: {url:string,filePath:string,name:string,header:Object,formData:Object,success:(res:any)=>void,fail:(res:any)=>void,complete:(res:any)=>void}): UploadTask;\r\n    /**\r\n     * 通过 wx.login 接口获得的用户登录态拥有一定的时效性。用户越久未使用小程序，用户登录态越有可能失效。反之如果用户一直在使用小程序，则用户登录态一直保持有效。具体时效逻辑由微信维护，对开发者透明。开发者只需要调用 wx.checkSession 接口检测当前用户登录态是否有效。登录态过期后开发者可以再调用 wx.login 获取新的用户登录态。\r\n     */\r\n    checkSession(object: {success:(res:any)=>void,fail:(res:any)=>void,complete:(res:any)=>void}): void;\r\n    /**\r\n     * 调用接口获取登录凭证（code）进而换取用户登录态信息，包括用户的唯一标识（openid） 及本次登录的 会话密钥（session_key）等。用户数据的加解密通讯需要依赖会话密钥完成。\r\n     */\r\n    login(object: {success:(res:any)=>void,fail:(res:any)=>void,complete:(res:any)=>void}): void;\r\n    authorize(object: {scope:string,success:(res:any)=>void,fail:(res:any)=>void,complete:(res:any)=>void}): void;\r\n    /**\r\n     * 在无须用户授权的情况下，批量获取用户信息。该接口只在开放数据域下可用\r\n     */\r\n    getUserInfo(object: {withCredentials:boolean,lang:string,success:(res:any)=>void,fail:(res:any)=>void,complete:(res:any)=>void}): void;\r\n    getSetting(object: {success:(res:any)=>void,fail:(res:any)=>void,complete:(res:any)=>void}): void;\r\n    openSetting(object: {success:(res:any)=>void,fail:(res:any)=>void,complete:(res:any)=>void}): void;\r\n    getWeRunData(object: {success:(res:any)=>void,fail:(res:any)=>void,complete:(res:any)=>void}): void;\r\n    /**\r\n     * 拉取当前用户所有同玩好友的托管数据。该接口只可在开放数据域下使用\r\n     */\r\n    getFriendCloudStorage(object: {keyList:any[],success:(res:any)=>void,fail:(res:any)=>void,complete:(res:any)=>void}): void;\r\n    /**\r\n     * 在小游戏是通过群分享卡片打开的情况下，可以通过调用该接口获取群同玩成员的游戏数据。该接口只可在开放数据域下使用。\r\n     */\r\n    getGroupCloudStorage(object: {shareTicket:string,keyList:any[],success:(res:any)=>void,fail:(res:any)=>void,complete:(res:any)=>void}): void;\r\n    /**\r\n     * 获取当前用户托管数据当中对应 key 的数据。该接口只可在开放数据域下使用\r\n     */\r\n    getUserCloudStorage(object: {keyList:any[],success:(res:any)=>void,fail:(res:any)=>void,complete:(res:any)=>void}): void;\r\n    /**\r\n     * 删除用户托管数据当中对应 key 的数据。\r\n     */\r\n    removeUserCloudStorage(object: {keyList:any[],success:(res:any)=>void,fail:(res:any)=>void,complete:(res:any)=>void}): void;\r\n    /**\r\n     * 对用户托管数据进行写数据操作，允许同时写多组 KV 数据。\r\n     */\r\n    setUserCloudStorage(object: {KVDataList:any[],success:(res:any)=>void,fail:(res:any)=>void,complete:(res:any)=>void}): void;\r\n    /**\r\n     * 获取开放数据域\r\n     */\r\n    getOpenDataContext(): OpenDataContext;\r\n    /**\r\n     * 监听主域发送的消息\r\n     */\r\n    onMessage(callback: (data:any)=>void): void;\r\n    getShareInfo(object: {shareTicket:string,success:(res:any)=>void,fail:(res:any)=>void,complete:(res:any)=>void}): void;\r\n    hideShareMenu(object: {success:(res:any)=>void,fail:(res:any)=>void,complete:(res:any)=>void}): void;\r\n    /**\r\n     * 监听用户点击右上角菜单的“转发”按钮时触发的事件\r\n     */\r\n    onShareAppMessage(callback: ()=>void): void;\r\n\r\n    aldOnShareAppMessage(callback: ()=>void): void;\r\n    /**\r\n     * 取消监听用户点击右上角菜单的“转发”按钮时触发的事件\r\n     */\r\n    offShareAppMessage(callback: ()=>void): void;\r\n    showShareMenu(object: {withShareTicket:boolean,success:(res:any)=>void,fail:(res:any)=>void,complete:(res:any)=>void}): void;\r\n    /**\r\n     * 主动拉起转发，进入选择通讯录界面。\r\n     */\r\n    shareAppMessage(object: {title:string,imageUrl:string,query?:string,success?:(res:any)=>void,fail?:(res:any)=>void,complete?:(res:any)=>void}): void;\r\n    aldShareAppMessage(object: {title:string,imageUrl:string,query?:string,success?:(res:any)=>void,fail?:(res:any)=>void,complete?:(res:any)=>void}): void;\r\n    \r\n    updateShareMenu(object: {withShareTicket:boolean,success:(res:any)=>void,fail:(res:any)=>void,complete:(res:any)=>void}): void;\r\n    setEnableDebug(object: {enableDebug:boolean,success:(res:any)=>void,fail:(res:any)=>void,complete:(res:any)=>void}): void;\r\n    /**\r\n     * 清理本地数据缓存\r\n     */\r\n    clearStorage(object: {success:(res:any)=>void,fail:(res:any)=>void,complete:(res:any)=>void}): void;\r\n    /**\r\n     * wx.clearStorage 的同步版本\r\n     */\r\n    clearStorageSync(): void;\r\n    /**\r\n     * 从本地缓存中异步获取指定 key 的内容\r\n     */\r\n    getStorage(object: {key:string,success:(res:any)=>void,fail:(res:any)=>void,complete:(res:any)=>void}): void;\r\n    /**\r\n     * 异步获取当前storage的相关信息\r\n     */\r\n    getStorageInfo(object: {success:(res:any)=>void,fail:(res:any)=>void,complete:(res:any)=>void}): void;\r\n    /**\r\n     * wx.getStorage 的同步版本\r\n     */\r\n    getStorageSync(key: string): Object|string;\r\n    /**\r\n     * wx.getStorageInfo 的同步版本\r\n     */\r\n    getStorageInfoSync(): Object;\r\n    /**\r\n     * 从本地缓存中移除指定 key\r\n     */\r\n    removeStorage(object: {key:string,success:(res:any)=>void,fail:(res:any)=>void,complete:(res:any)=>void}): void;\r\n    /**\r\n     * wx.removeStorage 的同步版本\r\n     */\r\n    removeStorageSync(key: string): void;\r\n    /**\r\n     * 将数据存储在本地缓存中指定的 key 中，会覆盖掉原来该 key 对应的内容。\r\n     */\r\n    setStorage(object: {key:string,data:Object|string,success:(res:any)=>void,fail:(res:any)=>void,complete:(res:any)=>void}): void;\r\n    /**\r\n     * wx.setStorage 的同步版本\r\n     */\r\n    setStorageSync(key: string, data: Object|string): void;\r\n    /**\r\n     * 隐藏消息提示框\r\n     */\r\n    hideToast(object: {success:(res:any)=>void,fail:(res:any)=>void,complete:(res:any)=>void}): void;\r\n    hideLoading(object: {success?:(res:any)=>void,fail?:(res:any)=>void,complete?:(res:any)=>void}): void;\r\n    /**\r\n     * 显示模态对话框\r\n     */\r\n    showModal(object: {title:string,content:string,showCancel?:boolean,cancelText?:string,cancelColor?:string,confirmText?:string,confirmColor?:string,success?:(res:any)=>void,fail?:(res:any)=>void,complete?:(res:any)=>void}): void;\r\n    /**\r\n     * 显示消息提示框\r\n     */\r\n    showToast(object: {title:Object,icon?:Object,image?:Object,success?:(res:any)=>void,fail?:(res:any)=>void,complete?:(res:any)=>void}): void;\r\n    showLoading(object: {title:string,mask?:boolean,success?:(res:any)=>void,fail?:(res:any)=>void,complete?:(res:any)=>void}): void;\r\n    /**\r\n     * 参数\r\n     */\r\n    showActionSheet(object: {itemList:any[],itemColor:string,success:(res:any)=>void,fail:(res:any)=>void,complete:(res:any)=>void}): void;\r\n    /**\r\n     * 隐藏键盘\r\n     */\r\n    hideKeyboard(object: {success:(res:any)=>void,fail:(res:any)=>void,complete:(res:any)=>void}): void;\r\n    /**\r\n     * 监听键盘输入事件\r\n     */\r\n    onKeyboardInput(callback: ()=>void): void;\r\n    /**\r\n     * 取消监听键盘输入事件\r\n     */\r\n    offKeyboardInput(callback: ()=>void): void;\r\n    /**\r\n     * 监听用户点击键盘 Confirm 按钮时的事件\r\n     */\r\n    onKeyboardConfirm(callback: ()=>void): void;\r\n    /**\r\n     * 取消监听用户点击键盘 Confirm 按钮时的事件\r\n     */\r\n    offKeyboardConfirm(callback: ()=>void): void;\r\n    /**\r\n     * 监听监听键盘收起的事件\r\n     */\r\n    onKeyboardComplete(callback: ()=>void): void;\r\n    /**\r\n     * 取消监听监听键盘收起的事件\r\n     */\r\n    offKeyboardComplete(callback: ()=>void): void;\r\n    /**\r\n     * 显示键盘\r\n     */\r\n    showKeyboard(object: {defaultValue:string,maxLength:number,multiple:boolean,confirmHold:boolean,confirmType:string,success:(res:any)=>void,fail:(res:any)=>void,complete:(res:any)=>void}): void;\r\n    /**\r\n     * 动态设置通过右上角按钮拉起的菜单的样式。\r\n     */\r\n    setMenuStyle(object: {style:string,success:(res:any)=>void,fail:(res:any)=>void,complete:(res:any)=>void}): void;\r\n    /**\r\n     * 当在配置中设置 showStatusBarStyle 时，屏幕顶部会显示状态栏。此接口可以修改状态栏的样式。\r\n     */\r\n    setStatusBarStyle(object: {style:string,success:(res:any)=>void,fail:(res:any)=>void,complete:(res:any)=>void}): void;\r\n    /**\r\n     * 监听窗口尺寸变化事件\r\n     */\r\n    onWindowResize(callback: ()=>void): void;\r\n    /**\r\n     * 取消监听窗口尺寸变化事件\r\n     */\r\n    offWindowResize(callback: ()=>void): void;\r\n    /**\r\n     * 返回值\r\n     */\r\n    getUpdateManager(): UpdateManager;\r\n    /**\r\n     * 创建一个 Worker 线程，目前限制最多只能创建一个 Worker，创建下一个 Worker 前请调用 Worker.terminate\r\n     */\r\n    createWorker(): Worker;\r\n    /**\r\n     * 创建一个 InnerAudioContext 实例\r\n     */\r\n    createInnerAudioContext(): InnerAudioContext;\r\n    getRecorderManager(): RecorderManager;\r\n    /**\r\n     * 从本地相册选择图片或使用相机拍照。\r\n     */\r\n    chooseImage(object: {count:number}): void;\r\n    /**\r\n     * 预览图片\r\n     */\r\n    previewImage(object: {current:string,urls:any[],success:(res:any)=>void,fail?:(res:any)=>void,complete?:(res:any)=>void}): void;\r\n    saveImageToPhotosAlbum(object: {filePath:string,success:(res:any)=>void,fail:(res:any)=>void,complete:(res:any)=>void}): void;\r\n    /**\r\n     * 创建视频\r\n     */\r\n    createVideo(object: {x:number,y:number,width:number,height:number,src:number,poster:number,initialTime:number,playbackRate:number,live:number,objectFit:number,controls:number,autoplay:number,loop:number,muted:number}): Video;\r\n    /**\r\n     * 获取性能管理器\r\n     */\r\n    getPerformance(): Performance;\r\n    /**\r\n     * 加快触发 JavaScrpitCore Garbage Collection（垃圾回收），GC 时机是由 JavaScrpitCore 来控制的，并不能保证调用后马上触发 GC。\r\n     */\r\n    triggerGC(): void;\r\n    /**\r\n     * 发起米大师支付\r\n     */\r\n    requestMidasPayment(object: {mode:string,env:number,offerId:string,currencyType:string,platform:string,buyQuantity:number,zoneId:string,success:(res:any)=>void,fail:(res:any)=>void,complete:(res:any)=>void}): void;\r\n}\r\n\r\ndeclare interface Canvas {\r\n    /**\r\n     * 获取画布对象的绘图上下文\r\n     */\r\n    getContext(contextType: string, contextAttributes: {antialias:boolean,preserveDrawingBuffer:boolean,antialiasSamples:number}): RenderingContext;\r\n    /**\r\n     * 将当前 Canvas 保存为一个临时文件，并生成相应的临时文件路径。\r\n     */\r\n    toTempFilePath(object: {x:number,y:number,width:number,height:number,destWidth:number,destHeight:number,fileType:string,quality:number,success:(res:any)=>void,fail:(res:any)=>void,complete:(res:any)=>void}): string;\r\n    /**\r\n     * 把画布上的绘制内容以一个 data URI 的格式返回\r\n     */\r\n    toDataURL(): string;\r\n    /**\r\n     * Canvas.toTempFilePath 的同步版本\r\n     */\r\n    toTempFilePathSync(object: {x:number,y:number,width:number,height:number,destWidth:number,destHeight:number,fileType:string,quality:number}): void;\r\n}\r\n\r\ndeclare interface FileSystemManager {\r\n    /**\r\n     * 判断文件/目录是否存在\r\n     */\r\n    access(object: {path:string,success:(res:any)=>void,fail:(res:any)=>void,complete:(res:any)=>void}): void;\r\n    /**\r\n     * FileSystemManager.access 的同步版本\r\n     */\r\n    accessSync(path: string): void;\r\n    /**\r\n     * 复制文件\r\n     */\r\n    copyFile(object: {srcPath:string,destPath:string,success:(res:any)=>void,fail:(res:any)=>void,complete:(res:any)=>void}): void;\r\n    /**\r\n     * FileSystemManager.copyFile 的同步版本\r\n     */\r\n    copyFileSync(srcPath: string, destPath: string): void;\r\n    /**\r\n     * 获取该小程序下的 本地临时文件 或 本地缓存文件 信息\r\n     */\r\n    getFileInfo(object: {filePath:string,success:(res:any)=>void,fail:(res:any)=>void,complete:(res:any)=>void}): void;\r\n    /**\r\n     * 获取该小程序下已保存的本地缓存文件列表\r\n     */\r\n    getSavedFileList(object: {success:(res:any)=>void,fail:(res:any)=>void,complete:(res:any)=>void}): void;\r\n    /**\r\n     * 创建目录\r\n     */\r\n    mkdir(object: {dirPath:string,success:(res:any)=>void,fail:(res:any)=>void,complete:(res:any)=>void}): void;\r\n    /**\r\n     * FileSystemManager.mkdir 的同步版本\r\n     */\r\n    mkdirSync(dirPath: string): void;\r\n    /**\r\n     * 删除该小程序下已保存的本地缓存文件\r\n     */\r\n    removeSavedFile(object: {filePath:string,success:(res:any)=>void,fail:(res:any)=>void,complete:(res:any)=>void}): void;\r\n    /**\r\n     * 读取本地文件内容\r\n     */\r\n    readFile(object: {filePath:string,encoding:string,success:(res:any)=>void,fail:(res:any)=>void,complete:(res:any)=>void}): void;\r\n    /**\r\n     * 重命名文件，可以把文件从 oldPath 移动到 newPath\r\n     */\r\n    rename(object: {oldPath:string,newPath:string,success:(res:any)=>void,fail:(res:any)=>void,complete:(res:any)=>void}): void;\r\n    /**\r\n     * 删除目录\r\n     */\r\n    rmdir(object: {dirPath:Object,success:(res:any)=>void,fail:(res:any)=>void,complete:(res:any)=>void}): void;\r\n    /**\r\n     * 读取目录内文件列表\r\n     */\r\n    readdir(object: {dirPath:string,success:(res:any)=>void,fail:(res:any)=>void,complete:(res:any)=>void}): void;\r\n    /**\r\n     * FileSystemManager.readdir 的同步版本\r\n     */\r\n    readdirSync(dirPath: string): string[];\r\n    /**\r\n     * FileSystemManager.rename 的同步版本\r\n     */\r\n    renameSync(oldPath: string, newPath: string): void;\r\n    /**\r\n     * FileSystemManager.rmdir 的同步版本\r\n     */\r\n    rmdirSync(dirPath: {}): void;\r\n    /**\r\n     * FileSystemManager.readFile 的同步版本\r\n     */\r\n    readFileSync(filePath: string, encoding: string): string[];\r\n    /**\r\n     * 保存临时文件到本地。此接口会移动临时文件，因此调用成功后，tempFilePath 将不可用。\r\n     */\r\n    saveFile(object: {tempFilePath:string,filePath:string,success:(res:any)=>void,fail:(res:any)=>void,complete:(res:any)=>void}): void;\r\n    /**\r\n     * 获取文件 Stats 对象\r\n     */\r\n    stat(object: {path:string,success:(res:any)=>void,fail:(res:any)=>void,complete:(res:any)=>void}): Stats;\r\n    /**\r\n     * FileSystemManager.saveFile 的同步版本\r\n     */\r\n    saveFileSync(tempFilePath: string, filePath: string): number;\r\n    /**\r\n     * FileSystemManager.stat 的同步版本\r\n     */\r\n    statSync(path: string): Stats;\r\n    /**\r\n     * 删除文件\r\n     */\r\n    unlink(object: {filePath:string,success:(res:any)=>void,fail:(res:any)=>void,complete:(res:any)=>void}): void;\r\n    /**\r\n     * 解压文件\r\n     */\r\n    unzip(object: {zipFilePath:string,targetPath:string,success:(res:any)=>void,fail:(res:any)=>void,complete:(res:any)=>void}): void;\r\n    /**\r\n     * FileSystemManager.unlink 的同步版本\r\n     */\r\n    unlinkSync(filePath: string): void;\r\n    /**\r\n     * 写文件\r\n     */\r\n    writeFile(object: {filePath:string,data:any[],encoding:string,success:(res:any)=>void,fail:(res:any)=>void,complete:(res:any)=>void}): void;\r\n    /**\r\n     * FileSystemManager.writeFile 的同步版本\r\n     */\r\n    writeFileSync(filePath: string, data: string|ArrayBuffer, encoding: string): void;\r\n}\r\n\r\ndeclare interface Stats {\r\n    /**\r\n     * 判断当前文件是否一个目录\r\n     */\r\n    isDirectory(): boolean;\r\n    /**\r\n     * 判断当前文件是否一个普通文件\r\n     */\r\n    isFile(): boolean;\r\n}\r\n\r\ndeclare interface DownloadTask {\r\n    abort(): void;\r\n    onProgressUpdate(callback: ()=>void): void;\r\n}\r\n\r\ndeclare interface RequestTask {\r\n    abort(): void;\r\n}\r\n\r\ndeclare interface SocketTask {\r\n    /**\r\n     * 关闭 WebSocket 连接\r\n     */\r\n    close(object: {code:number,reason:string,success:(res:any)=>void,fail:(res:any)=>void,complete:(res:any)=>void}): void;\r\n    /**\r\n     * 监听WebSocket 连接打开事件\r\n     */\r\n    onOpen(callback: ()=>void): void;\r\n    /**\r\n     * 监听WebSocket 连接关闭事件\r\n     */\r\n    onClose(callback: ()=>void): void;\r\n    /**\r\n     * 监听WebSocket 错误事件\r\n     */\r\n    onError(callback: ()=>void): void;\r\n    /**\r\n     * 监听WebSocket 接受到服务器的消息事件\r\n     */\r\n    onMessage(callback: ()=>void): void;\r\n    /**\r\n     * 通过 WebSocket 连接发送数据\r\n     */\r\n    send(object: {data:any[],success:(res:any)=>void,fail:(res:any)=>void,complete:(res:any)=>void}): void;\r\n}\r\n\r\ndeclare interface UploadTask {\r\n    abort(): void;\r\n    onProgressUpdate(callback: ()=>void): void;\r\n}\r\n\r\ndeclare interface OpenDataContext {\r\n    /**\r\n     * 向开放数据域发送消息\r\n     */\r\n    postMessage(message: {}): void;\r\n}\r\n\r\ndeclare interface UpdateManager {\r\n    /**\r\n     * 应用更新包并重启\r\n     */\r\n    applyUpdate(): void;\r\n    /**\r\n     * 监听检查更新结果回调\r\n     */\r\n    onCheckForUpdate(callback: ()=>void): void;\r\n    /**\r\n     * 监听更新包下载成功回调\r\n     */\r\n    onUpdateReady(callback: ()=>void): void;\r\n    /**\r\n     * 监听更新包下载失败回调\r\n     */\r\n    onUpdateFailed(callback: ()=>void): void;\r\n}\r\n\r\ndeclare interface Worker {\r\n    /**\r\n     * 监听接收主线程/Worker 线程向当前线程发送的消息\r\n     */\r\n    onMessage(callback: ()=>void): void;\r\n    /**\r\n     * 向主线程/Worker 线程发送的消息。\r\n     */\r\n    postMessage(message: {}): void;\r\n    /**\r\n     * 结束当前 worker 线程，仅限在主线程 worker 对象上调用。\r\n     */\r\n    terminate(): void;\r\n}\r\n\r\ndeclare interface InnerAudioContext {\r\n    /**\r\n     * 销毁当前实例\r\n     */\r\n    destroy(): void;\r\n    /**\r\n     * 取消监听音频进入可以播放状态的事件\r\n     */\r\n    offCanplay(callback: ()=>void): void;\r\n    /**\r\n     * 监听音频暂停事件\r\n     */\r\n    onPause(callback: ()=>void): void;\r\n    /**\r\n     * 监听音频停止事件\r\n     */\r\n    onStop(callback: ()=>void): void;\r\n    /**\r\n     * 取消监听音频停止事件\r\n     */\r\n    offStop(callback: ()=>void): void;\r\n    /**\r\n     * 监听音频自然播放至结束的事件\r\n     */\r\n    onEnded(callback: ()=>void): void;\r\n    /**\r\n     * 取消监听音频自然播放至结束的事件\r\n     */\r\n    offEnded(callback: ()=>void): void;\r\n    /**\r\n     * 监听音频播放进度更新事件\r\n     */\r\n    onTimeUpdate(callback: ()=>void): void;\r\n    /**\r\n     * 监听音频播放事件\r\n     */\r\n    onPlay(callback: ()=>void): void;\r\n    /**\r\n     * 监听音频播放错误事件\r\n     */\r\n    onError(callback: ()=>void): void;\r\n    /**\r\n     * 取消监听音频暂停事件\r\n     */\r\n    offPause(callback: ()=>void): void;\r\n    /**\r\n     * 监听音频加载中事件，当音频因为数据不足，需要停下来加载时会触发\r\n     */\r\n    onWaiting(callback: ()=>void): void;\r\n    /**\r\n     * 取消监听音频加载中事件，当音频因为数据不足，需要停下来加载时会触发\r\n     */\r\n    offWaiting(callback: ()=>void): void;\r\n    /**\r\n     * 监听音频进行跳转操作的事件\r\n     */\r\n    onSeeking(callback: ()=>void): void;\r\n    /**\r\n     * 取消监听音频进行跳转操作的事件\r\n     */\r\n    offSeeking(callback: ()=>void): void;\r\n    /**\r\n     * 监听音频完成跳转操作的事件\r\n     */\r\n    onSeeked(callback: ()=>void): void;\r\n    /**\r\n     * 取消监听音频完成跳转操作的事件\r\n     */\r\n    offSeeked(callback: ()=>void): void;\r\n    /**\r\n     * 取消监听音频播放事件\r\n     */\r\n    offPlay(callback: ()=>void): void;\r\n    /**\r\n     * 取消监听音频播放进度更新事件\r\n     */\r\n    offTimeUpdate(callback: ()=>void): void;\r\n    /**\r\n     * 监听音频进入可以播放状态的事件\r\n     */\r\n    onCanplay(callback: ()=>void): void;\r\n    /**\r\n     * 取消监听音频播放错误事件\r\n     */\r\n    offError(callback: ()=>void): void;\r\n    /**\r\n     * 停止。停止后的音频再播放会从头开始播放。\r\n     */\r\n    pause(): void;\r\n    /**\r\n     * 播放\r\n     */\r\n    play(): void;\r\n    /**\r\n     * 跳转到指定位置，单位 s\r\n     */\r\n    seek(position: number): void;\r\n}\r\n\r\ndeclare interface RecorderManager {\r\n    /**\r\n     * 监听录音暂停事件\r\n     */\r\n    onPause(callback: ()=>void): void;\r\n    /**\r\n     * 监听录音结束事件\r\n     */\r\n    onStop(callback: ()=>void): void;\r\n    /**\r\n     * 监听已录制完指定帧大小的文件事件。如果设置了 frameSize，则会回调此事件。\r\n     */\r\n    onFrameRecorded(callback: ()=>void): void;\r\n    /**\r\n     * 监听录音错误事件\r\n     */\r\n    onError(callback: ()=>void): void;\r\n    /**\r\n     * 监听录音开始事件\r\n     */\r\n    onStart(callback: ()=>void): void;\r\n    /**\r\n     * 暂停录音\r\n     */\r\n    pause(): void;\r\n    /**\r\n     * 继续录音\r\n     */\r\n    resume(): void;\r\n    /**\r\n     * 停止录音\r\n     */\r\n    stop(): void;\r\n    /**\r\n     * 开始录音\r\n     */\r\n    start(object: {duration:number,sampleRate:number,numberOfChannels:number,encodeBitRate:number,format:string,frameSize:number}): void;\r\n}\r\n\r\ndeclare interface Video {\r\n    /**\r\n     * 视频退出全屏\r\n     */\r\n    exitFullScreen(): Promise<Object>;\r\n    /**\r\n     * 取消监听视频暂停事件\r\n     */\r\n    offPause(callback: ()=>void): void;\r\n    /**\r\n     * 监听视频播放到末尾事件\r\n     */\r\n    onEnded(callback: ()=>void): void;\r\n    /**\r\n     * 取消监听视频播放到末尾事件\r\n     */\r\n    offEnded(callback: ()=>void): void;\r\n    /**\r\n     * 监听视频播放进度更新事件\r\n     */\r\n    onTimeUpdate(callback: ()=>void): void;\r\n    /**\r\n     * 取消监听视频播放进度更新事件\r\n     */\r\n    offTimeUpdate(callback: ()=>void): void;\r\n    /**\r\n     * 监听视频错误事件\r\n     */\r\n    onError(callback: ()=>void): void;\r\n    /**\r\n     * 取消监听视频错误事件\r\n     */\r\n    offError(callback: ()=>void): void;\r\n    /**\r\n     * 监听视频播放事件\r\n     */\r\n    onPlay(callback: ()=>void): void;\r\n    /**\r\n     * 监听视频暂停事件\r\n     */\r\n    onPause(callback: ()=>void): void;\r\n    /**\r\n     * 取消监听视频缓冲事件\r\n     */\r\n    offWaiting(callback: ()=>void): void;\r\n    /**\r\n     * 监听视频缓冲事件\r\n     */\r\n    onWaiting(callback: ()=>void): void;\r\n    /**\r\n     * 取消监听视频播放事件\r\n     */\r\n    offPlay(callback: ()=>void): void;\r\n    /**\r\n     * 暂停视频\r\n     */\r\n    pause(): Promise<Object>;\r\n    /**\r\n     * 播放视频\r\n     */\r\n    play(): Promise<Object>;\r\n    /**\r\n     * 视频全屏\r\n     */\r\n    requestFullScreen(): Promise<Object>;\r\n    /**\r\n     * 视频跳转\r\n     */\r\n    seek(time: number): Promise<Object>;\r\n    /**\r\n     * 停止视频\r\n     */\r\n    stop(): Promise<Object>;\r\n}\r\n\r\ndeclare interface Performance {\r\n    /**\r\n     * 可以获取当前时间以微秒为单位的时间戳\r\n     */\r\n    now(): number;\r\n}\r\n\r\n\r\ndeclare interface Image {\r\n    /**\r\n     * 图片的 URL\r\n     */\r\n    src: string;\r\n    /**\r\n    * 图片的真实宽度\r\n    */\r\n    width: number;\r\n    /**\r\n    * 图片的真实高度\r\n    */\r\n    height: number;\r\n    /**\r\n     * 图片的加载完成\r\n     */\r\n    onload: () => void;\r\n}\r\n\r\ndeclare class LaunchOption {\r\n    /** 场景值*/\r\n    scene: number;\r\n    /** 启动参数*/\r\n    query: Object;\r\n    /** 当前小游戏是否被显示在聊天顶部*/\r\n    isSticky: boolean;\r\n    /** shareTicket*/\r\n    shareTicket: string;\r\n}\r\n\r\ndeclare class SystemInfo {\r\n    /** 手机品牌*/\r\n    brand: string;\r\n    /** 手机型号*/\r\n    model: string;\r\n    /**\t设备像素比 */\r\n    pixelRatio: number;\r\n    /** 屏幕宽度*/\r\n    screenWidth: number;\r\n    /** 屏幕高度*/\r\n    screenHeight: number;\r\n    /** 可使用窗口宽度*/\r\n    windowWidth: number;\r\n    /** 可使用窗口高度*/\r\n    windowHeight: number;\r\n    /** 微信设置的语言*/\r\n    language: string;\r\n    /** 微信版本号*/\r\n    version: string;\r\n    /** 操作系统版本*/\r\n    system: string;\r\n    /** 客户端平台*/\r\n    platform: string\r\n    /** 用户字体大小设置。以“我-设置 - 通用 - 字体大小”中的设置为准，单位 px。*/\r\n    fontSizeSetting: number;\r\n    /** 客户端基础库版本*/\r\n    SDKVersion: string;\r\n    /** 性能等级*/\r\n    benchmarkLevel: number;\r\n    /** 电量，范围 1 - 100*/\r\n    battery: number;\r\n    /** wifi 信号强度，范围 0 - 4 */\r\n    wifiSignal: number;\r\n}\r\n\r\ndeclare class Stats {\r\n    /**\r\n     * 文件的类型和存取的权限，对应 POSIX stat.st_mode\r\n     */\r\n    mode: string;\r\n    /**\r\n     * 文件大小，单位：B，对应 POSIX stat.st_size\r\n     */\r\n    size: number;\r\n    /**\r\n     * 文件最近一次被存取或被执行的时间，UNIX 时间戳，对应 POSIX stat.st_atime\r\n     */\r\n    lastAccessedTime: number;\r\n    /**\r\n    * 文件最后一次被修改的时间，UNIX 时间戳，对应 POSIX stat.st_mtime\r\n    */\r\n    lastModifiedTime: number;\r\n}\r\n\r\n /**\r\n  * 通过 Canvas.getContext('2d') 接口可以获取 CanvasRenderingContext2D 对象。CanvasRenderingContext2D 实现了 HTML The 2D rendering context 定义的大部分属性、方法。通过 Canvas.getContext('webgl') 接口可以获取 WebGLRenderingContext 对象。 WebGLRenderingContext 实现了 WebGL 1.0 定义的所有属性、方法、常量。\r\n  * 2d 接口支持情况\r\n  * iOS/Android 不支持的 2d 属性和接口\r\n  * globalCompositeOperation 不支持以下值： source-in source-out destination-atop lighter copy。如果使用，不会报错，但是将得到与预期不符的结果。\r\n  * isPointInPath\r\n  * WebGL 接口支持情况\r\n  * iOS/Android 不支持的 WebGL 接\r\n   */\r\ndeclare interface RenderingContext {}"
}