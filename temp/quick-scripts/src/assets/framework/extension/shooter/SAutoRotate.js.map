{"version":3,"sources":["assets\\framework\\extension\\shooter\\SAutoRotate.ts"],"names":[],"mappings":"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","file":"","sourceRoot":"/","sourcesContent":["import GameEntity from \"./SGameEntity\";\r\nimport ccUtil from \"../../utils/ccUtil\";\r\n\r\nconst { ccclass, property, menu } = cc._decorator;\r\n\r\nenum State {\r\n    Idle,\r\n    Rotate,\r\n}\r\n\r\n\r\n@ccclass\r\n@menu(\"shooter/AutoRotate\")\r\nexport default class SAutoRotate extends cc.Component {\r\n\r\n    // seekPlayer:boolean = true;\r\n    // seekNearest:boolean = true;\r\n\r\n    @property(GameEntity)\r\n    target: GameEntity = null;\r\n\r\n    // rotateRange:number = 10;\r\n\r\n    @property\r\n    maxTurnRate: number = 0.02; //  360 s  \r\n\r\n    static inaccuracyScalar = 3;\r\n\r\n    // private targetAngle: number = 0;\r\n\r\n    heading: cc.Vec2 = cc.v2(1, 0);\r\n\r\n    isRotating: boolean = false;\r\n\r\n    /**可以旋转到后背 */\r\n    canRotateBack: boolean = false;\r\n\r\n\r\n    onLoad() {\r\n        if (this.node.scaleX < 0) {\r\n            this.heading = cc.v2(-1, 0);\r\n        }\r\n    }\r\n\r\n    isBackRotate(toTarget: cc.Vec2) {\r\n        if (!this.canRotateBack) {\r\n            if (this.node.scaleX < 0) {\r\n                if (toTarget.x > 0) {\r\n                    return true;\r\n                }\r\n            } else {\r\n                if (toTarget.x < 0) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    rotate() {\r\n        if (!cc.isValid(this.target)) {\r\n            this.rotateToVec()\r\n            return 0\r\n        }\r\n        if (this.target) {\r\n            if (this.target.isDead()) {\r\n                this.rotateToVec()\r\n                return 0;\r\n            }\r\n        }\r\n        let box = ccUtil.getWorldBoundingBox(this.node);\r\n        let targetpos = ccUtil.getWorldPosition(this.target.node);\r\n        let toTarget = targetpos.sub(box.center);\r\n        if (this.isBackRotate(toTarget)) {\r\n            this.rotateToVec()\r\n            return;\r\n        }\r\n        toTarget.normalizeSelf();\r\n        return this.rotateToVec(toTarget);\r\n    }\r\n\r\n    signVec2(v1, v2) {\r\n        if (v1.y * v2.x > v1.x * v2.y) {\r\n            return -1\r\n        }\r\n        else {\r\n            return 1;\r\n        }\r\n    }\r\n\r\n    rotateToVec(toTarget: cc.Vec2 = null) {\r\n        if (toTarget == null) {\r\n            if (this.node.scaleX < 0) {\r\n                toTarget = cc.v2(-1, 0)\r\n            } else {\r\n                toTarget = cc.Vec2.RIGHT;\r\n            }\r\n        }\r\n        // let toTarget = cc.v2(1,0);\r\n        let sign = this.signVec2(this.heading, toTarget);\r\n        let angle = Math.acos(this.heading.dot(toTarget))\r\n        if (angle < 0.0001) {\r\n            return 0\r\n        };\r\n        if (isNaN(angle)) {\r\n            angle = 0;\r\n        }\r\n        if (angle > this.maxTurnRate) {\r\n            angle = this.maxTurnRate;\r\n        }\r\n        this.heading.rotateSelf(sign * angle);\r\n        let a = this.heading.signAngle(cc.Vec2.RIGHT)\r\n        this.node.angle = cc.macro.DEG * a;\r\n        if (this.node.scaleX < 0) {\r\n            this.node.angle += 180;\r\n        }\r\n        return 1;\r\n    }\r\n\r\n\r\n    update(dt) {\r\n        this.isRotating = !!this.rotate()\r\n    }\r\n\r\n\r\n}"]}