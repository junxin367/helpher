{"version":3,"sources":["assets\\framework\\utils\\mathf.ts"],"names":[],"mappings":";;;;;;AAAA;IAAA;IAwDA,CAAC;IAvDiB,WAAK,GAAnB,UAAoB,KAAK,EAAE,GAAG,EAAE,GAAG;QAC/B,IAAI,KAAK,GAAG,GAAG;YACX,KAAK,GAAG,GAAG,CAAC;aACX,IAAI,KAAK,GAAG,GAAG;YAChB,KAAK,GAAG,GAAG,CAAC;QAChB,OAAO,KAAK,CAAC;IACjB,CAAC;IAED,sFAAsF;IACxE,YAAM,GAApB,UAAqB,CAAC,EAAE,MAAM;QAC1B,OAAO,KAAK,CAAC,KAAK,CAAC,CAAC,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC,GAAG,MAAM,CAAC,GAAG,MAAM,EAAE,GAAG,EAAE,MAAM,CAAC,CAAC;IACzE,CAAC;IAED,0FAA0F;IAC5E,cAAQ,GAAtB,UAAuB,CAAC,EAAE,MAAM;QAC5B,CAAC,GAAG,KAAK,CAAC,MAAM,CAAC,CAAC,EAAE,MAAM,GAAG,CAAC,CAAC,CAAC;QAChC,OAAO,MAAM,GAAG,IAAI,CAAC,GAAG,CAAC,CAAC,GAAG,MAAM,CAAC,CAAC;IACzC,CAAC;IAED,8DAA8D;IAChD,iBAAW,GAAzB,UAA0B,CAAC,EAAE,CAAC,EAAE,KAAK;QACjC,IAAI,CAAC,IAAI,CAAC;YACN,OAAO,KAAK,CAAC,OAAO,CAAC,CAAC,KAAK,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;;YAE5C,OAAO,GAAG,CAAC;IACnB,CAAC;IAED,+DAA+D;IACjD,gBAAU,GAAxB,UAAyB,OAAO,EAAE,MAAM;QACpC,IAAI,KAAK,GAAG,KAAK,CAAC,MAAM,CAAC,CAAC,MAAM,GAAG,OAAO,CAAC,EAAE,KAAK,CAAC,CAAC;QACpD,IAAI,KAAK,GAAG,GAAG;YACX,KAAK,IAAI,GAAG,CAAC;QACjB,OAAO,KAAK,CAAC;IACjB,CAAC;IAEa,aAAO,GAArB,UAAsB,KAAK;QACvB,IAAI,KAAK,GAAG,CAAC;YACT,OAAO,CAAC,CAAC;aACR,IAAI,KAAK,GAAG,CAAC;YACd,OAAO,CAAC,CAAC;;YAET,OAAO,KAAK,CAAC;IACrB,CAAC;IAED,2EAA2E;IAC7D,UAAI,GAAlB,UAAmB,CAAC,EAAE,CAAC,EAAE,CAAC;QACtB,OAAO,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,GAAG,KAAK,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC;IAC1C,CAAC;IAEa,eAAS,GAAvB,UAAwB,CAAC,EAAE,CAAC,EAAE,CAAC;QAC3B,IAAI,KAAK,GAAG,KAAK,CAAC,MAAM,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,EAAE,GAAG,CAAC,CAAC;QACvC,IAAI,KAAK,GAAG,GAAG;YACX,KAAK,IAAI,GAAG,CAAC;QACjB,OAAO,CAAC,GAAG,KAAK,GAAG,KAAK,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC;IACxC,CAAC;IACL,YAAC;AAAD,CAxDA,AAwDC,IAAA","file":"","sourceRoot":"/","sourcesContent":["export default class mathf {\r\n    public static Clamp(value, min, max) {\r\n        if (value < min)\r\n            value = min;\r\n        else if (value > max)\r\n            value = max;\r\n        return value;\r\n    }\r\n\r\n    // Loops the value t, so that it is never larger than length and never smaller than 0.\r\n    public static Repeat(t, length) {\r\n        return mathf.Clamp(t - Math.floor(t / length) * length, 0.0, length);\r\n    }\r\n\r\n    // PingPongs the value t, so that it is never larger than length and never smaller than 0.\r\n    public static PingPong(t, length) {\r\n        t = mathf.Repeat(t, length * 2);\r\n        return length - Math.abs(t - length);\r\n    }\r\n\r\n    // Calculates the ::ref::Lerp parameter between of two values.\r\n    public static InverseLerp(a, b, value) {\r\n        if (a != b)\r\n            return mathf.Clamp01((value - a) / (b - a));\r\n        else\r\n            return 0.0;\r\n    }\r\n\r\n    // Calculates the shortest difference between two given angles.\r\n    public static DeltaAngle(current, target) {\r\n        let delta = mathf.Repeat((target - current), 360.0);\r\n        if (delta > 180)\r\n            delta -= 360;\r\n        return delta;\r\n    }\r\n\r\n    public static Clamp01(value) {\r\n        if (value < 0)\r\n            return 0;\r\n        else if (value > 1)\r\n            return 1;\r\n        else\r\n            return value;\r\n    }\r\n\r\n    // Interpolates between /a/ and /b/ by /t/. /t/ is clamped between 0 and 1.\r\n    public static Lerp(a, b, t) {\r\n        return a + (b - a) * mathf.Clamp01(t);\r\n    }\r\n\r\n    public static LerpAngle(a, b, t) {\r\n        let delta = mathf.Repeat((b - a), 360);\r\n        if (delta > 180)\r\n            delta -= 360;\r\n        return a + delta * mathf.Clamp01(t);\r\n    }\r\n}\r\n"]}